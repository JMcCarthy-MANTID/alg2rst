This algorithm is able to generate event splitters according to user's requirement for filtering events.  The generated time splitters are stored either in a [[SplittersWorkspace]] or a [[MatrixWorkspace]].  Both of them will be used by algorithm [[FilterEvents]] to filter events from an [[EventWorkspace]].

This algorithm is designed as a general-purposed event splitter generator.  Combined with [[FilterEvents]], it will replace
* [[FilterByTime]]
* [[FilterByLogValue]]

Moreover, the time resolution of these two algorithms is microseconds, i.e., the wall time of an (neutron) event.  While the original [[FilterByTime]] and [[FilterByLogValue]] are of the resolution of pulse time.
It is also enhanced to process the fast frequency sample logs, which can be even faster than chopper frequencies.

=== Workspace to store event splitters ===
An event splitter used in Mantid contains start time, stop time and target workspace.
Any data structure that has the above 3 properties can serve as event splitter.
There are 2 types of output workspaces storing event splitters that are supported by this algorithm.

* [[SplittersWorkspace]]: It is a [[TableWorskpace]] that has 3 columns for start time, stop time and target workspace for events within start time and stop time.  This type of workspace is appropriate for the case that the amount of generated event splitters are not huge;
* [[MatrixWorkspace]]: It uses X-axis to store time stamp in total nanoseconds and Y-axis to store target workspace.  For example, x_i, x_i+1 and y_i construct an event filter as start time is x_i, stop time is x_i+i, and target workspace is y_i-th workspace.  If y_i is less than 0, then it means that all events between time x_i and x_i+1 will be discarded.  This type of workspace is appropriate for the case that the amount of generated event splitters are huge, because processing a [[MatrixWorkspace]] is way faster than a [[TableWorkspace]] in Mantid.

=== Functionalities ===
Here are the types of event filters (i.e., [[SplittersWorkspace]]) that can be generated by this algorithm:
* A filter for one time interval.

* A series of filters for multiple continuous time intervals, which have the same length of period.  Each of them has an individual workspace index associated.  These workspace indices are incremented by 1 from 0 along with their orders in time.

* A filter containing one or multiple time intervals according to a specified log value.  Any log value of the time that falls into the selected time intervals is equal or within the tolerance of a user specified value.

* A series filters containing one or multiple time intervals according to specified log values incremented by a constant value.  Any log value of the time that falls into the selected time intervals is equal or within the tolerance of the log value as v_0 + n x delta_v +/- tolerance_v.

==== Parameter: ''Centre'' ====
The input Boolean parameter ''centre'' is for filtering by log value(s).  If option ''centre'' is taken, then for each interval,
* starting time = log_time - tolerance_time;
* stopping time = log_time - tolerance_time;

It is a shift to left.

==== Parameter: ''LogValueTolerance'' and ''LogValueInterval'' ====
These two parameters are used to determine the log value intervals for filtering events.

Let user-specified minimum log value to be 'min',  LogValueTolerance to be 'tol', and LogValueInterval to be 'delta', then the log value intervals are (min-tol, min-tol+delta), (min-tol+delta, min-tol+2delta), ...

The default value of LogValueTolerance is LogValueInterval devided by 2.

==== About how log value is recorded ====
SNS DAS records log values upon its changing.  The frequency of log sampling is significantly faster than change of the log, i.e., sample environment devices.  Therefore, it is reasonable to assume that all the log value changes as step functions.

The option to do interpolation is not supported at this moment.

=== Comparison to FilterByLogValue ===
1. If the first log value is within the specified range and the first log time is after run star time,
FilterByLogValue assumes that the log value before the first recorded log time is also within range, and thus
the first splitter starts from the run star time, while GenerateEventFilter tends to be more conservative,
and thus the first splitter will start from the first log time.

2. FilterByLogValue only filters events at the resolution of pulse time, while [[GenerateEventsFilter]] can improve the resolution to 1 micro second.